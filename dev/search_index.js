var documenterSearchIndex = {"docs":
[{"location":"reference/KKT/kkt/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"reference/KKT/kkt/","page":"Overview","title":"Overview","text":"The KKT module provides a modular, customizable interface for developing and selecting various approaches to solve the KKT systems.","category":"page"},{"location":"reference/KKT/kkt/#KKT-backends","page":"Overview","title":"KKT backends","text":"","category":"section"},{"location":"reference/KKT/kkt/#Tulip.KKT.AbstractKKTBackend","page":"Overview","title":"Tulip.KKT.AbstractKKTBackend","text":"AbstractKKTBackend\n\nAbstract type for KKT backend, i.e., the actual linear solver.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt/#Tulip.KKT.DefaultKKTBackend","page":"Overview","title":"Tulip.KKT.DefaultKKTBackend","text":"DefaultKKTBackend\n\nDefault setting for KKT backend.\n\nCurrently defaults to TlpCholmod.Backend for Float64 arithmetic,     and TlpLDLFact.Backend otherwise.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt/#KKT-systems","page":"Overview","title":"KKT systems","text":"","category":"section"},{"location":"reference/KKT/kkt/","page":"Overview","title":"Overview","text":"All formulations below refer to a linear program in primal-dual standard form","category":"page"},{"location":"reference/KKT/kkt/","page":"Overview","title":"Overview","text":"    beginarrayrl\n    (P)    \n    displaystyle min_x\n     c^top x\n    st\n     A x = b\n     l leq x leq u\n    endarray\n    quad quad quad\n    beginarrayrl\n    (D)    \n    displaystyle max_y z\n     b^top y + l^topz^l - u^topz^u\n    st\n     A^topy + z^l - z^u = c\n     z^l z^u geq 0\n    endarray","category":"page"},{"location":"reference/KKT/kkt/#Tulip.KKT.AbstractKKTSystem","page":"Overview","title":"Tulip.KKT.AbstractKKTSystem","text":"AbstractKKTSystem\n\nAbstract type for KKT systems\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt/#Tulip.KKT.DefaultKKTSystem","page":"Overview","title":"Tulip.KKT.DefaultKKTSystem","text":"DefaultKKTSystem\n\nDefault KKT system setting. Currently equivalent to K2\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt/#Tulip.KKT.K2","page":"Overview","title":"Tulip.KKT.K2","text":"K2 <: AbstractKKTSystem\n\nAugmented system\n\n    beginbmatrix\n        -(Theta^-1 + R_p)  A^top\n        A  R_d\n    endbmatrix\n    beginbmatrix\n        Delta x\n        Delta y\n    endbmatrix\n    =\n    beginbmatrix\n        xi_d\n        xi_p\n    endbmatrix\n\nwhere\n\nTheta^-1 = X^-lZ^l + X^-u Z^u\nR_p R_d are current primal and dual regularizations\nxi_d xi_p are given right-hand sides\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt/#Tulip.KKT.K1","page":"Overview","title":"Tulip.KKT.K1","text":"K1 <: AbstractKKTSystem\n\nNormal equations system\n\n    beginarrayrl\n    left(\n        A (Theta^-1 + R_p)^-1 A^top + R_d\n    right)\n    Delta y\n     =\n    xi_p + A (Θ^-1 + R_p)^-1 xi_d\n    Delta x = (Θ^-1 + R_p)^-1 (A^top Delta y - xi_d)\n    endarray\n\nwhere\n\nTheta^-1 = X^-lZ^l + X^-u Z^u\nR_p R_d are current primal and dual regularizations\nxi_d xi_p are the augmented system's right-hand side\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt/#KKT-solvers","page":"Overview","title":"KKT solvers","text":"","category":"section"},{"location":"reference/KKT/kkt/#Tulip.KKT.AbstractKKTSolver","page":"Overview","title":"Tulip.KKT.AbstractKKTSolver","text":"AbstractKKTSolver{T}\n\nAbstract container for solving KKT systems in arithmetic T.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt/","page":"Overview","title":"Overview","text":"Custom linear solvers should (preferably) inherit from the AbstractKKTSolver class, and extend the following functions:","category":"page"},{"location":"reference/KKT/kkt/#Tulip.KKT.setup","page":"Overview","title":"Tulip.KKT.setup","text":"setup(A, system, backend; kwargs...)\n\nInstantiate a KKT solver object.\n\n\n\n\n\n","category":"function"},{"location":"reference/KKT/kkt/#Tulip.KKT.update!","page":"Overview","title":"Tulip.KKT.update!","text":"update!(kkt, θinv, regP, regD)\n\nUpdate internal data and factorization/pre-conditioner.\n\nAfter this call, kkt can be used to solve the augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nfor given right-hand sides ξd and ξp.\n\nArguments\n\nkkt::AbstractKKTSolver{T}: the KKT solver object\nθinv::AbstractVector{T}: θ¹\nregP::AbstractVector{T}: primal regularizations\nregD::AbstractVector{T}: dual regularizations\n\n\n\n\n\n","category":"function"},{"location":"reference/KKT/kkt/#Tulip.KKT.solve!","page":"Overview","title":"Tulip.KKT.solve!","text":"solve!(dx, dy, kkt, ξp, ξd)\n\nSolve the symmetric quasi-definite augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nand over-write dx, dy with the result.\n\nArguments\n\ndx, dy: Vectors of unknowns, modified in-place\nkkt: Linear solver for the augmented system\nξp, ξd: Right-hand-side vectors\n\n\n\n\n\n","category":"function"},{"location":"reference/KKT/tlp_dense/#TlpDense","page":"TlpDense","title":"TlpDense","text":"","category":"section"},{"location":"reference/KKT/tlp_dense/#Tulip.KKT.TlpDense.Backend","page":"TlpDense","title":"Tulip.KKT.TlpDense.Backend","text":"Backend\n\nDense linear algebra backend for solving linear systems.\n\nSee DenseSolver for further details.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/tlp_dense/#Tulip.KKT.TlpDense.DenseSolver","page":"TlpDense","title":"Tulip.KKT.TlpDense.DenseSolver","text":"DenseSolver{T}\n\nDense linear algebra-based KKT solver.\n\nSupported arithmetics\n\nAll arithmetics are supported.\n\nBLAS/LAPACK routines are used automatically with Float32 and Float64 arithmetic.\n\nSupported systems\n\nK1 via Cholesky factorization\n\n\n\n\n\n","category":"type"},{"location":"manual/IPM/MPC/#Predictor-Corrector-algorithm","page":"Predictor-Corrector","title":"Predictor-Corrector algorithm","text":"","category":"section"},{"location":"manual/IPM/MPC/#Tulip.MPC","page":"Predictor-Corrector","title":"Tulip.MPC","text":"MPC\n\nImplements Mehrotra's Predictor-Corrector interior-point algorithm.\n\n\n\n\n\n","category":"type"},{"location":"manual/IPM/MPC/#References","page":"Predictor-Corrector","title":"References","text":"","category":"section"},{"location":"manual/IPM/MPC/","page":"Predictor-Corrector","title":"Predictor-Corrector","text":"Mehrotra, S.   On the Implementation of a Primal-Dual Interior Point Method   SIAM Journal on Optimization, 1992, 2, 575-601","category":"page"},{"location":"manual/options/#Options-management","page":"Setting options","title":"Options management","text":"","category":"section"},{"location":"manual/options/","page":"Setting options","title":"Setting options","text":"info: Info\nThis part of the documentation is under construction","category":"page"},{"location":"manual/options/","page":"Setting options","title":"Setting options","text":"See Options reference for a list of all available options and their signification.","category":"page"},{"location":"manual/options/#Handling-options-within-JuMP","page":"Setting options","title":"Handling options within JuMP","text":"","category":"section"},{"location":"manual/options/#Handling-options-within-MOI","page":"Setting options","title":"Handling options within MOI","text":"","category":"section"},{"location":"manual/options/#Handling-options-directly","page":"Setting options","title":"Handling options directly","text":"","category":"section"},{"location":"tutorials/lp_example/#Toy-example","page":"Toy example","title":"Toy example","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"Tulip can be accessed in 3 ways: through JuMP, through MathOptInterface, or directly.","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"This tutorial illustrates, for each case, how to build a model, solve it, and query the solution value. In all cases, we consider the small LP","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"beginarrayrrrl\n    (LP)    \n    displaystyle Z^* = min_x y  -2x  - y\n    st\n      x  - y  geq -2\n     2x -  y  leq  4\n      x + 2y  leq  7\n      x   y  geq  0\nendarray","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"whose optimal value and solution are Z^* = -8 and (x^* y^*) = (3 2).","category":"page"},{"location":"tutorials/lp_example/#JuMP","page":"Toy example","title":"JuMP","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\nusing JuMP\nimport Tulip\n\n# Instantiate JuMP model\nlp = Model(Tulip.Optimizer)\n\n# Create variables\n@variable(lp, x >= 0)\n@variable(lp, y >= 0)\n\n# Add constraints\n@constraint(lp, row1, x - y >= -2)\n@constraint(lp, row2, 2*x - y <= 4)\n@constraint(lp, row3, x + 2*y <= 7)\n\n# Set the objective\n@objective(lp, Min, -2*x - y)\n\n# Set some parameters\nset_optimizer_attribute(lp, \"OutputLevel\", 0)  # disable output\nset_optimizer_attribute(lp, \"Presolve_Level\", 0)     # disable presolve\n\n# Solve the problem\noptimize!(lp)\n\n# Check termination status\nst = termination_status(lp)\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = objective_value(lp)\nx_ = value(x)\ny_ = value(y)\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"tutorials/lp_example/#MOI","page":"Toy example","title":"MOI","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\n\nimport MathOptInterface\nconst MOI = MathOptInterface\n\nimport Tulip\n\nlp = Tulip.Optimizer{Float64}()\n\n# Create variables\nx = MOI.add_variable(lp)\ny = MOI.add_variable(lp)\n\n# Set variable bounds\nMOI.add_constraint(lp, x, MOI.GreaterThan(0.0))  # x >= 0\nMOI.add_constraint(lp, y, MOI.GreaterThan(0.0))  # y >= 0\n\n# Add constraints\nrow1 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1.0, -1.0], [x, y]), 0.0),\n    MOI.GreaterThan(-2.0)\n)\nrow2 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([2.0, -1.0], [x, y]), 0.0),\n    MOI.LessThan(4.0)\n)\nrow3 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1.0,  2.0], [x, y]), 0.0),\n    MOI.LessThan(7.0)\n) \n\n# Set the objective\nMOI.set(lp,\n    MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([-2.0, -1.0], [x, y]), 0.0)\n)\nMOI.set(lp, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n\n# Set some parameters\nMOI.set(lp, MOI.Silent(), true)               # disable output\nMOI.set(lp, MOI.RawOptimizerAttribute(\"Presolve_Level\"), 0)  # disable presolve\n\n# Solve the problem\nMOI.optimize!(lp)\n\n# Check status\nst = MOI.get(lp, MOI.TerminationStatus())\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = MOI.get(lp, MOI.ObjectiveValue())\nx_ = MOI.get(lp, MOI.VariablePrimal(), x)\ny_ = MOI.get(lp, MOI.VariablePrimal(), y)\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"tutorials/lp_example/#Tulip","page":"Toy example","title":"Tulip","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"warning: Warning\nTulip's low-level API should not be considered stable nor complete. The recommended way to use Tulip is through JuMP/MOI as shown above.","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\nimport Tulip\n\n# Instantiate Tulip object\nlp = Tulip.Model{Float64}()\npb = lp.pbdata  # Internal problem data\n\n# Create variables\nx = Tulip.add_variable!(pb, Int[], Float64[], -2.0, 0.0, Inf, \"x\")\ny = Tulip.add_variable!(pb, Int[], Float64[], -1.0, 0.0, Inf, \"y\")\n\n# Add constraints\nrow1 = Tulip.add_constraint!(pb, [x, y], [1.0, -1.0], -2.0, Inf, \"row1\")\nrow2 = Tulip.add_constraint!(pb, [x, y], [2.0, -1.0], -Inf, 4.0, \"row2\")\nrow3 = Tulip.add_constraint!(pb, [x, y], [1.0,  2.0], -Inf, 7.0, \"row3\")\n\n# Set the objective\n# Nothing to do here as objective is already declared\n\n# Set some parameters\nTulip.set_parameter(lp, \"OutputLevel\", 0)  # disable output\nTulip.set_parameter(lp, \"Presolve_Level\", 0)     # disable presolve\n\n# Solve the problem\nTulip.optimize!(lp)\n\n# Check termination status\nst = Tulip.get_attribute(lp, Tulip.Status())\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = Tulip.get_attribute(lp, Tulip.ObjectiveValue())\nx_ = lp.solution.x[x]\ny_ = lp.solution.x[y]\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"manual/IPM/HSD/#Homogeneous-Self-Dual-algorithm","page":"Homogeneous Self-Dual","title":"Homogeneous Self-Dual algorithm","text":"","category":"section"},{"location":"manual/IPM/HSD/#Tulip.HSD","page":"Homogeneous Self-Dual","title":"Tulip.HSD","text":"HSD\n\nSolver for the homogeneous self-dual algorithm.\n\n\n\n\n\n","category":"type"},{"location":"manual/IPM/HSD/#References","page":"Homogeneous Self-Dual","title":"References","text":"","category":"section"},{"location":"manual/IPM/HSD/","page":"Homogeneous Self-Dual","title":"Homogeneous Self-Dual","text":"Anjos, M.F.; Lodi, A.; Tanneau, M.   Design and implementation of a modular interior-point solver for linear optimization","category":"page"},{"location":"reference/KKT/tlp_krylov/#TlpKrylov","page":"TlpKrylov","title":"TlpKrylov","text":"","category":"section"},{"location":"reference/KKT/tlp_krylov/","page":"TlpKrylov","title":"TlpKrylov","text":"warning: Warning\nIterative methods are still an experimental feature. Some numerical and performance issues should be expected.","category":"page"},{"location":"reference/KKT/tlp_krylov/#Tulip.KKT.TlpKrylov.Backend","page":"TlpKrylov","title":"Tulip.KKT.TlpKrylov.Backend","text":"Backend{KS<:Krylov.KrylovWorkspace,V<:AbstractVector}\n\nKrylov.jl-based backend for solving linear systems.\n\nThe type is parametrized by:\n\nKS<:Krylov.KrylovWorkspace: workspace type for the Krylov method.   Also defines the Krylov method to be used.\nV<:AbstractVector: the vector storage type used within the Krylov method.   This should be set to Vector{T} (for arithmetic T) unless, e.g., one uses a GPU.\n\nSee the Krylov.jl documentation for further details.\n\nExample usage\n\nAll the following examples assume everything runs on a CPU in Float64 arithmetic.\n\nTo use the conjugate gradient:\n\nbackend = KKT.TlpKrylov.Backend(Krylov.CgWorkspace, Vector{Float64})\n\nTo use MINRES:\n\nbackend = KKT.TlpKrylov.Backend(Krylov.MinresWorkspace, Vector{Float64})\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/tlp_krylov/#Tulip.KKT.TlpKrylov.AbstractKrylovSolver","page":"TlpKrylov","title":"Tulip.KKT.TlpKrylov.AbstractKrylovSolver","text":"AbstractKrylovSolver{T}\n\nAbstract type for Kyrlov-based linear solvers.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/tlp_krylov/#Tulip.KKT.TlpKrylov.SPDSolver","page":"TlpKrylov","title":"Tulip.KKT.TlpKrylov.SPDSolver","text":"SPDSolver\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/tlp_krylov/#Tulip.KKT.TlpKrylov.SIDSolver","page":"TlpKrylov","title":"Tulip.KKT.TlpKrylov.SIDSolver","text":"SIDSolver\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/tlp_krylov/#Tulip.KKT.TlpKrylov.SQDSolver","page":"TlpKrylov","title":"Tulip.KKT.TlpKrylov.SQDSolver","text":"SQDSolver\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/tlp_ldlfact/#TlpLDLFactorizations","page":"TlpLDLFactorizations","title":"TlpLDLFactorizations","text":"","category":"section"},{"location":"reference/KKT/tlp_ldlfact/#Tulip.KKT.TlpLDLFactorizations.Backend","page":"TlpLDLFactorizations","title":"Tulip.KKT.TlpLDLFactorizations.Backend","text":"Backend\n\nLDLFactorizations backend for solving linear systems.\n\nSee LDLFactSolver for further details.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/tlp_ldlfact/#Tulip.KKT.TlpLDLFactorizations.LDLFactSolver","page":"TlpLDLFactorizations","title":"Tulip.KKT.TlpLDLFactorizations.LDLFactSolver","text":"LDLFactSolver{T,S<:AbstractKKTSystem}\n\nLDLFactorizations.jl-based KKT solver.\n\nSupported arithmetics\n\nAll arithmetics are supported\n\nSupported systems\n\nK2 via LDLᵀ factorization\n\nExamples\n\nTo solve the augmented system with LDLFactorizations' LDL^T factorization:\n\nset_parameter(tlp_model, \"KKT_Backend\", Tulip.KKT.TlpLDLFact.Backend())\nset_parameter(tlp_model, \"KKT_System\", Tulip.KKT.K2())\n\n\n\n\n\n","category":"type"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model, Tulip.BarrierIterations}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::BarrierIterations)\n\nQuery the BarrierIterations attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model, Tulip.ConstraintName, Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::ConstraintName, i::Int)\n\nQuery the name of constraint i in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model, Tulip.ModelName}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ModelName)\n\nQuery the ModelName attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model, Tulip.SolutionTime}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::SolutionTime)\n\nQuery the SolutionTime attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model, Tulip.Status}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::Status)\n\nQuery the Status attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model, Tulip.VariableLowerBound, Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model{T}, ::VariableLowerBound, j::Int)\n\nQuery the lower bound of variable j in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model, Tulip.VariableName, Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::VariableName, j::Int)\n\nQuery the name of variable j in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T}, Tulip.DualObjectiveValue}} where T","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::DualObjectiveValue)\n\nQuery the DualObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T}, Tulip.ObjectiveValue}} where T","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ObjectiveValue)\n\nQuery the ObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_parameter-Tuple{Tulip.Model, String}","page":"Julia API","title":"Tulip.get_parameter","text":"get_parameter(m::Model, pname::String)\n\nQuery the value of parameter pname in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.load_problem!-Union{Tuple{T}, Tuple{Tulip.Model{T}, String}} where T","page":"Julia API","title":"Tulip.load_problem!","text":"load_problem!(m::Model{T}, fname::String)\n\nRead a model from file fname and load it into model m.\n\nOnly free MPS files are currently supported.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model, Tulip.ConstraintName, Int64, String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::ConstraintName, i::Int, name::String)\n\nSet the name of constraint i in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model, Tulip.ModelName, String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(model::Model, ::ModelName, name::String)\n\nSet the ModelName attribute in model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model, Tulip.VariableName, Int64, String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::VariableName, j::Int, name::String)\n\nSet the name of variable j in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T}, Tulip.ConstraintLowerBound, Int64, T}} where T","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{T}, ::ConstraintLowerBound, i::Int, lb::T)\n\nSet the lower bound of constraint i in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T}, Tulip.ConstraintUpperBound, Int64, T}} where T","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{T}, ::ConstraintUpperBound, i::Int, ub::T)\n\nSet the upper bound of constraint i in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T}, Tulip.VariableLowerBound, Int64, T}} where T","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{T}, ::VariableLowerBound, j::Int, lb::T)\n\nSet the lower bound of variable j in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T}, Tulip.VariableUpperBound, Int64, T}} where T","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{T}, ::VariableUpperBound, j::Int, ub::T)\n\nSet the upper bound of variable j in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_parameter-Tuple{Tulip.Model, String, Any}","page":"Julia API","title":"Tulip.set_parameter","text":"set_parameter(m::Model, pname::String, val)\n\nSet the value of parameter pname in model m to val\n\n\n\n\n\n","category":"method"},{"location":"reference/KKT/tlp_cholmod/#TlpCholmod","page":"TlpCholmod","title":"TlpCholmod","text":"","category":"section"},{"location":"reference/KKT/tlp_cholmod/#Tulip.KKT.TlpCholmod.Backend","page":"TlpCholmod","title":"Tulip.KKT.TlpCholmod.Backend","text":"Backend\n\nCHOLMOD backend for solving linear systems.\n\nSee CholmodSolver for further details.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/tlp_cholmod/#Tulip.KKT.TlpCholmod.CholmodSolver","page":"TlpCholmod","title":"Tulip.KKT.TlpCholmod.CholmodSolver","text":"CholmodSolver{T,S<:AbstractKKTSystem}\n\nCHOLMOD-based KKT solver.\n\nSupported arithmetics\n\nFloat64\n\nSupported systems\n\nK2 via LDLᵀ factorization\nK1 via Cholesky (LLᵀ) factorization\n\nExamples\n\nTo solve the augmented system with CHOLMOD's LDL^T factorization:\n\nset_parameter(tlp_model, \"KKT_Backend\", Tulip.KKT.TlpCholmod.Backend())\nset_parameter(tlp_model, \"KKT_System\", Tulip.KKT.K2())\n\nTo solve the normal equations system with CHOLMOD's Cholesky factorization:\n\nset_parameter(tlp_model, \"KKT_Backend\", Tulip.KKT.TlpCholmod.Backend())\nset_parameter(tlp_model, \"KKT_System\", Tulip.KKT.K1())\n\n\n\n\n\n","category":"type"},{"location":"manual/formulation/#Problem-formulation","page":"Problem formulation","title":"Problem formulation","text":"","category":"section"},{"location":"manual/formulation/#Model-input","page":"Problem formulation","title":"Model input","text":"","category":"section"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"Tulip takes as input LP problems of the form","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrrcll\n    (P)    \n    displaystyle min_x  c^Tx  +  c_0\n    st\n     l^b_i leq  a_i^T x  leq u^b_i  forall i = 1  m\n     l^x_j leq  x_j  leq u^x_j  forall j = 1  n\n    endarray","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"where l^bx u^b x in mathbbR cup  - infty + infty , i.e., some of the bounds may be infinite.","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"This original formulation is then converted to standard form.","category":"page"},{"location":"manual/formulation/#Standard-form","page":"Problem formulation","title":"Standard form","text":"","category":"section"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"Internally, Tulip solves LPs of the form","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrl\n    (P)    \n    displaystyle min_x\n     c^T x +  c_0\n    st\n     A x = b\n     l leq x leq u\n    endarray","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"where x c in mathbbR^n, A in mathbbR^m times n, b in mathbbR^m, and  l u in (mathbbR cup -infty +infty )^n, i.e., some bounds may be infinite.","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"The original problem is automatically reformulated into standard form before the optimization is performed. This transformation is transparent to the user.","category":"page"},{"location":"reference/attributes/#Attribute-reference","page":"Attributes","title":"Attribute reference","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Attributes are queried using get_attribute and set using set_attribute.","category":"page"},{"location":"reference/attributes/#Model-attributes","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nModelName String Name of the model\nNumberOfConstraints Int Number of constraints in the model\nNumberOfVariables Int Number of variables in the model\nObjectiveValue T Objective value of the current primal solution\nDualObjectiveValue T Objective value of the current dual solution\nObjectiveConstant T Value of the objective constant\nObjectiveSense  Optimization sense\nStatus  Model status\nBarrierIterations Int Number of barrier iterations\nSolutionTime Float64 Solution time, in seconds","category":"page"},{"location":"reference/attributes/#Variable-attributes","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nVariableLowerBound T Variable lower bound\nVariableUpperBound T Variable upper bound\nVariableObjectiveCoeff T Variable objective coefficient\nVariableName String Variable name","category":"page"},{"location":"reference/attributes/#Constraint-attributes","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nConstraintLowerBound T Constraint lower bound\nConstraintUpperBound T Constraint upper bound\nConstraintName String Constraint name","category":"page"},{"location":"reference/attributes/#Reference","page":"Attributes","title":"Reference","text":"","category":"section"},{"location":"reference/attributes/#Model-attributes-2","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/#Tulip.BarrierIterations","page":"Attributes","title":"Tulip.BarrierIterations","text":"BarrierIterations\n\nNumber of iterations of the barrier algorithm in the last call.\n\nThis number may be zero in the following cases:\n\nthe model has been solved yet\npresolve solved the model\nthe initial solution was optimal\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.BarrierIterations())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.DualObjectiveValue","page":"Attributes","title":"Tulip.DualObjectiveValue","text":"DualObjectiveValue\n\nObjective value of the current dual solution.\n\nType: T\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.DualObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ModelName","page":"Attributes","title":"Tulip.ModelName","text":"ModelName\n\nThe name of the model.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ModelName(), \"lp_example\")\nTulip.get_attribute(model, Tulip.ModelName())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfConstraints","page":"Attributes","title":"Tulip.NumberOfConstraints","text":"NumberOfConstraints\n\nNumber of constraints in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfConstraints())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfVariables","page":"Attributes","title":"Tulip.NumberOfVariables","text":"NumberOfVariables\n\nNumber of variables in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfVariables())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveConstant","page":"Attributes","title":"Tulip.ObjectiveConstant","text":"ObjectiveConstant\n\nConstant objective offset, defaults to zero.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ObjectiveConstant(), zero(T))\nTulip.get_attribute(model, Tulip.ObjectiveConstant())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveSense","page":"Attributes","title":"Tulip.ObjectiveSense","text":"ObjectiveSense\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveValue","page":"Attributes","title":"Tulip.ObjectiveValue","text":"ObjectiveValue\n\nObjective value of the current primal solution.\n\nType: T\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.ObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.SolutionTime","page":"Attributes","title":"Tulip.SolutionTime","text":"SolutionTime\n\nTotal solution time, in seconds.\n\nType: Float64\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.SolutionTime())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.Status","page":"Attributes","title":"Tulip.Status","text":"Status\n\nModel status\n\nType:\n\nModifiable: No\n\nExamples\n\nTulip.get(model, Tulip.Status())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Variable-attributes-2","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/#Tulip.VariableLowerBound","page":"Attributes","title":"Tulip.VariableLowerBound","text":"VariableLowerBound\n\nVariable lower bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableLowerBound(), 1, zero(T))\nTulip.get_attribute(model, Tulip.VariableLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableName","page":"Attributes","title":"Tulip.VariableName","text":"VariableName\n\nName of the variable.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableName(), 1, \"x1\")\nTulip.get_attribute(model, Tulip.VariableName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableObjectiveCoeff","page":"Attributes","title":"Tulip.VariableObjectiveCoeff","text":"VariableObjectiveCoeff\n\nObjective coefficient of the variable.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableObjectiveCoeff(), 1, one(T))\nTulip.get_attribute(model, Tulip.VariableObjectiveCoeff(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableUpperBound","page":"Attributes","title":"Tulip.VariableUpperBound","text":"VariableUpperBound\n\nVariable upper bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableUpperBound(), 1, one(T))\nTulip.get_attribute(model, Tulip.VariableUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Constraint-attributes-2","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/#Tulip.ConstraintLowerBound","page":"Attributes","title":"Tulip.ConstraintLowerBound","text":"ConstraintLowerBound\n\nConstraint lower bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintLowerBound(), 1, zero(T))\nTulip.get_attribute(model, Tulip.ConstraintLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintName","page":"Attributes","title":"Tulip.ConstraintName","text":"ConstraintName\n\nName of the constraint.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintName(), 1, \"c1\")\nTulip.get_attribute(model, Tulip.ConstraintName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintUpperBound","page":"Attributes","title":"Tulip.ConstraintUpperBound","text":"ConstraintUpperBound\n\nConstraint upper bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintUpperBound(), 1, one(T))\nTulip.get_attribute(model, Tulip.ConstraintUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"#Tulip.jl","page":"Home","title":"Tulip.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tulip is an open-source interior-point solver for linear programming.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tulip is 100% Julia, so install it just like any Julia package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add Tulip","category":"page"},{"location":"","page":"Home","title":"Home","text":"No additional building step is required.","category":"page"},{"location":"#Citing-Tulip.jl","page":"Home","title":"Citing Tulip.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Tulip in your work, we kindly ask that you cite the following reference. The PDF is freely available here, and serves as a user manual for advanced users.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@TechReport{Tulip.jl,\n    title = {{Tulip}.jl: an open-source interior-point linear optimization\n    solver with abstract linear algebra},\n    url = {https://www.gerad.ca/fr/papers/G-2019-36},\n    Journal = {Les Cahiers du Gerad},\n    Author = {Anjos, Miguel F. and Lodi, Andrea and Tanneau, Mathieu},\n    year = {2019}\n}","category":"page"},{"location":"reference/options/#Options-reference","page":"Options","title":"Options reference","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameters can be queried and set through the get_parameter and set_parameter functions.","category":"page"},{"location":"reference/options/","page":"Options","title":"Options","text":"In all that follows, epsilon refers to the numerical precision, which is given by eps(Tv) where Tv is the arithmetic of the current model. For instance, in double-precision arithmetic, i.e., Tv=Float64, we have epsilon simeq 10^-16.","category":"page"},{"location":"reference/options/#Tulip.Factory","page":"Options","title":"Tulip.Factory","text":"Factory{T}\n\nFactory-like struct for passing options to lower-level components.\n\n\n\n\n\n","category":"type"},{"location":"reference/options/#IPM","page":"Options","title":"IPM","text":"","category":"section"},{"location":"reference/options/#Tolerances","page":"Options","title":"Tolerances","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Numerical tolerances for the interior-point algorithm.","category":"page"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nTolerancePFeas Primal feasibility tolerance sqrtepsilon\nToleranceDFeas Dual feasibility tolerance sqrtepsilon\nToleranceRGap Relative optimality gap tolerance sqrtepsilon\nToleranceIFeas Infeasibility tolerance sqrtepsilon","category":"page"},{"location":"reference/options/#Algorithmic-parameters","page":"Options","title":"Algorithmic parameters","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nBarrierAlgorithm Interior-point algorithm 1\nCorrectionLimit Maximum number of additional centrality corrections 5\nStepDampFactor Step 0.9995\nGammaMin Minimum value of gamma for computing correctors 0.1\nCentralityOutlierThreshold Relative threshold for computing extra centrality corrections 0.1\nPRegMin Minimum value of primal regularization sqrtepsilon\nDRegMin Minimum value of dual regularization sqrtepsilon","category":"page"},{"location":"reference/options/#Stopping-criterion","page":"Options","title":"Stopping criterion","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nIterationsLimit Maximum number of barrier iterations 100\nTimeLimit Time limit, in seconds Inf","category":"page"},{"location":"reference/options/#KKT","page":"Options","title":"KKT","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nBackend See KKT backends KKT.DefaultKKTBackend\nSystem See KKT systems KKT.DefaultKKTSystem","category":"page"},{"location":"reference/options/#Linear-Algebra","page":"Options","title":"Linear Algebra","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"These parameters control the linear algebra implementation","category":"page"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nMatrixFactory See Factory Factory(SparseMatrixCSC)","category":"page"},{"location":"reference/options/#Presolve","page":"Options","title":"Presolve","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"These parameters control the execution of the presolve phase. They should be called as \"Presolve_<Param>\".","category":"page"},{"location":"reference/options/#Others","page":"Options","title":"Others","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nOutputLevel Controls the solver's output 0\nThreads Maximum number of threads 1\nPresolve Presolve (no presolve if set to ≤ 0) 1","category":"page"}]
}
