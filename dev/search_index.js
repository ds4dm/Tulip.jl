var documenterSearchIndex = {"docs":
[{"location":"manual/IPM/MPC/#Predictor-Corrector-algorithm","page":"Predictor-Corrector","title":"Predictor-Corrector algorithm","text":"","category":"section"},{"location":"manual/IPM/MPC/","page":"Predictor-Corrector","title":"Predictor-Corrector","text":"Tulip.MPC","category":"page"},{"location":"manual/IPM/MPC/#Tulip.MPC","page":"Predictor-Corrector","title":"Tulip.MPC","text":"MPC\n\nImplements Mehrotra's Predictor-Corrector interior-point algorithm.\n\n\n\n\n\n","category":"type"},{"location":"manual/IPM/MPC/#References","page":"Predictor-Corrector","title":"References","text":"","category":"section"},{"location":"manual/IPM/MPC/","page":"Predictor-Corrector","title":"Predictor-Corrector","text":"Mehrotra, S.   On the Implementation of a Primal-Dual Interior Point Method   SIAM Journal on Optimization, 1992, 2, 575-601","category":"page"},{"location":"manual/options/","page":"Setting options","title":"Setting options","text":"CurrentModule = Tulip","category":"page"},{"location":"manual/options/#Options-management","page":"Setting options","title":"Options management","text":"","category":"section"},{"location":"manual/options/","page":"Setting options","title":"Setting options","text":"info: Info\nThis part of the documentation is under construction","category":"page"},{"location":"manual/options/","page":"Setting options","title":"Setting options","text":"See Options reference for a list of all available options and their signification.","category":"page"},{"location":"manual/options/#Handling-options-within-JuMP","page":"Setting options","title":"Handling options within JuMP","text":"","category":"section"},{"location":"manual/options/#Handling-options-within-MOI","page":"Setting options","title":"Handling options within MOI","text":"","category":"section"},{"location":"manual/options/#Handling-options-directly","page":"Setting options","title":"Handling options directly","text":"","category":"section"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CurrentModule = Tulip.KKT","category":"page"},{"location":"reference/KKT/kkt_solvers/#Overview","page":"KKT solvers","title":"Overview","text":"","category":"section"},{"location":"reference/KKT/kkt_solvers/#AbstractKKTSolver","page":"KKT solvers","title":"AbstractKKTSolver","text":"","category":"section"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"This is the base type from which all implementations should derive.","category":"page"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"AbstractKKTSolver","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.AbstractKKTSolver","page":"KKT solvers","title":"Tulip.KKT.AbstractKKTSolver","text":"AbstractKKTSolver{T}\n\nAbstract container for solving an augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nwhere ξd and ξp are given right-hand side.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Custom linear solvers should inherit from the AbstractKKTSolver class, and extend the following two functions:","category":"page"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"update!","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.update!","page":"KKT solvers","title":"Tulip.KKT.update!","text":"update!(kkt, θinv, regP, regD)\n\nUpdate internal data and factorization/pre-conditioner.\n\nAfter this call, kkt can be used to solve the augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nfor given right-hand sides ξd and ξp.\n\nArguments\n\nkkt::AbstractKKTSolver{T}: the KKT solver object\nθinv::AbstractVector{T}: θ¹\nregP::AbstractVector{T}: primal regularizations\nregD::AbstractVector{T}: dual regularizations\n\n\n\n\n\n","category":"function"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"solve!","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.solve!","page":"KKT solvers","title":"Tulip.KKT.solve!","text":"solve!(dx, dy, kkt, ξp, ξd)\n\nSolve the symmetric quasi-definite augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nand over-write dx, dy with the result.\n\nArguments\n\ndx, dy: Vectors of unknowns, modified in-place\nkkt: Linear solver for the augmented system\nξp, ξd: Right-hand-side vectors\n\n\n\n\n\n","category":"function"},{"location":"reference/KKT/kkt_solvers/#Choosing-between-linear-solvers","page":"KKT solvers","title":"Choosing between linear solvers","text":"","category":"section"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KKTOptions","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.KKTOptions","page":"KKT solvers","title":"Tulip.KKT.KKTOptions","text":"KKTOptions{T}\n\nKKT solver options.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/#Dense/LAPACK","page":"KKT solvers","title":"Dense/LAPACK","text":"","category":"section"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"DenseSPD","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.DenseSPD","page":"KKT solvers","title":"Tulip.KKT.DenseSPD","text":"DenseSPD{T}\n\nKKT solver for dense linear systems.\n\nUses a Cholesky factorization of the normal equations system. Not recommended     for systems of size larger than a few thousands.\n\nmodel = Tulip.Model{Float64}()\nmodel.params.KKT.Factory = Tulip.Factory(Tulip.KKT.DenseSPD)\n\ninfo: Info\nDispatches to BLAS/LAPACK in Float32 and Float64 arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/#CHOLMOD","page":"KKT solvers","title":"CHOLMOD","text":"","category":"section"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CholmodSolver","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.CholmodSolver","page":"KKT solvers","title":"Tulip.KKT.CholmodSolver","text":"CholmodSolver\n\nUses CHOLMOD's factorization routines to solve the augmented system.\n\nTo use an LDLᵀ factorization of the augmented system (see CholmodSQD)\n\nmodel.params.KKT.Factory = Tulip.Factory(CholmodSolver, normal_equations=false)\n\nTo use a Cholesky factorization of the normal equations system (see CholmodSPD)\n\nmodel.params.KKT.Factory = Tulip.Factory(CholmodSolver, normal_equations=true)\n\nwarning: Warning\nCHOLMOD can only be used with Float64 arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CholmodSQD","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.CholmodSQD","page":"KKT solvers","title":"Tulip.KKT.CholmodSQD","text":"CholmodSQD\n\nLinear solver for the 2x2 augmented system with A sparse.\n\nUses an LDLᵀ factorization of the quasi-definite augmented system.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CholmodSPD","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.CholmodSPD","page":"KKT solvers","title":"Tulip.KKT.CholmodSPD","text":"CholmodSPD\n\nLinear solver for the 2x2 augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nwith A sparse.\n\nUses a Cholesky factorization of the positive definite normal equations system\n\n(A * ((Θ⁻¹ + Rp)⁻¹ * Aᵀ + Rd) dy = ξp + A * (θ⁻¹ + Rp)⁻¹ * ξd\n                              dx = (Θ⁻¹ + Rp)⁻¹ * (Aᵀ * dy - ξd)\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/#LDLFactorizations","page":"KKT solvers","title":"LDLFactorizations","text":"","category":"section"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"LDLFactSQD","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.LDLFactSQD","page":"KKT solvers","title":"Tulip.KKT.LDLFactSQD","text":"LDLFactSQD{T}\n\nLinear solver for the 2x2 augmented system with A sparse.\n\nUses LDLFactorizations.jl to compute an LDLᵀ factorization of the quasi-definite augmented system.\n\nmodel.params.KKT.Factory = Tulip.Factory(LDLFactSQD)\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/#Krylov","page":"KKT solvers","title":"Krylov","text":"","category":"section"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"warning: Warning\nIterative methods are still an experimental feature. Some numerical and performance issues should be expected.","category":"page"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSPD","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.KrylovSPD","page":"KKT solvers","title":"Tulip.KKT.KrylovSPD","text":"KrylovSPD{T, F, Tv, Ta}\n\nKrylov-based Symmetric Positive-Definite (SPD) linear solver.\n\nApplies a Krylov method to the normal equations systems, then recovers a solution to the augmented system. The selected Krylov method must therefore handle symmetric positive-definite systems. Suitable methods are CG or CR.\n\nA KrylovSPD is selected as follows\n\nmodel.params.KKT.Factory = Tulip.Factory(\n    KrylovSPD, method=Krylov.cg,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\ndy, _ = f(S, ξ; atol, rtol)\n\nwhere S, ξ and dy are the normal equations system's left- and right-hand side, and solution vector, respectively. S may take the form of a matrix, or of a suitable linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSID","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.KrylovSID","page":"KKT solvers","title":"Tulip.KKT.KrylovSID","text":"KrylovSID{T, F, Tv, Ta}\n\nKrylov-based Symmetric InDefinite (SID) linear solver.\n\nApplies a Krylov method to solve the augmented system, without exploiting its quasi-definiteness properties. The selected Krylov method must therefore handle symmetric indefinite systems. Suitable methods are MINRES or MINRES-QLP.\n\nA KrylovSID is selected as follows\n\nmodel.params.KKT.Factory = Tulip.Factory(\n    KrylovSID, method=Krylov.minres,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\nΔ, _ = f(K, ξ; atol, rtol)\n\nwhere K, ξ and Δ are the augmented system's left- and right-hand side, and solution vector, respectively. K may take the form of a matrix, or of a suitable linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/KKT/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSQD","category":"page"},{"location":"reference/KKT/kkt_solvers/#Tulip.KKT.KrylovSQD","page":"KKT solvers","title":"Tulip.KKT.KrylovSQD","text":"KrylovSQD{T, F, Tv, Ta}\n\nKrylov-based Symmetric Quasi-Definite (SQD) linear solver.\n\nApplies a Krylov method to solve the augmented system, taking advantage of its 2x2 block structure and quasi-definiteness. The selected Krylov method must therefore handle 2x2 symmetric quasi-definite systems. Suitable methods are TriCG and TriMR.\n\nA KrylovSID is selected as follows\n\nmodel.params.KKT.Factory = Tulip.Factory(\n    KrylovSQD, method=Krylov.trimr,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\ndy, dx, _ = f(A, ξp, ξd; M, N, atol, rtol)\n\nwhere the augmented system is of the form\n\n[ -N⁻¹ Aᵀ ] [dx] = [ξd]\n[  A   M⁻¹] [dy] = [ξp]\n\ni.e., N = (Θ^-1 + R_p)^-1 and M = R_d^-1.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/lp_example/#Toy-example","page":"Toy example","title":"Toy example","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"Tulip can be accessed in 3 ways: through JuMP, through MathOptInterface, or directly.","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"This tutorial illustrates, for each case, how to build a model, solve it, and query the solution value. In all cases, we consider the small LP","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"beginarrayrrrl\n    (LP)    \n    displaystyle Z^* = min_x y  -2x  - y\n    st\n      x  - y  geq -2\n     2x -  y  leq  4\n      x + 2y  leq  7\n      x   y  geq  0\nendarray","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"whose optimal value and solution are Z^* = -8 and (x^* y^*) = (3 2).","category":"page"},{"location":"tutorials/lp_example/#JuMP","page":"Toy example","title":"JuMP","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\nusing JuMP\nimport Tulip\n\n# Instantiate JuMP model\nlp = Model(Tulip.Optimizer)\n\n# Create variables\n@variable(lp, x >= 0)\n@variable(lp, y >= 0)\n\n# Add constraints\n@constraint(lp, row1, x - y >= -2)\n@constraint(lp, row2, 2*x - y <= 4)\n@constraint(lp, row3, x + 2*y <= 7)\n\n# Set the objective\n@objective(lp, Min, -2*x - y)\n\n# Set some parameters\nset_optimizer_attribute(lp, \"OutputLevel\", 0)  # disable output\nset_optimizer_attribute(lp, \"Presolve_Level\", 0)     # disable presolve\n\n# Solve the problem\noptimize!(lp)\n\n# Check termination status\nst = termination_status(lp)\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = objective_value(lp)\nx_ = value(x)\ny_ = value(y)\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"tutorials/lp_example/#MOI","page":"Toy example","title":"MOI","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\n\nimport MathOptInterface\nconst MOI = MathOptInterface\n\nimport Tulip\n\nlp = Tulip.Optimizer{Float64}()\n\n# Create variables\nx = MOI.add_variable(lp)\ny = MOI.add_variable(lp)\n\n# Set variable bounds\nMOI.add_constraint(lp, MOI.SingleVariable(x), MOI.GreaterThan(0.0))  # x >= 0\nMOI.add_constraint(lp, MOI.SingleVariable(y), MOI.GreaterThan(0.0))  # y >= 0\n\n# Add constraints\nrow1 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1.0, -1.0], [x, y]), 0.0),\n    MOI.GreaterThan(-2.0)\n)\nrow2 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([2.0, -1.0], [x, y]), 0.0),\n    MOI.LessThan(4.0)\n)\nrow3 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1.0,  2.0], [x, y]), 0.0),\n    MOI.LessThan(7.0)\n) \n\n# Set the objective\nMOI.set(lp,\n    MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([-2.0, -1.0], [x, y]), 0.0)\n)\nMOI.set(lp, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n\n# Set some parameters\nMOI.set(lp, MOI.Silent(), true)               # disable output\nMOI.set(lp, MOI.RawParameter(\"Presolve_Level\"), 0)  # disable presolve\n\n# Solve the problem\nMOI.optimize!(lp)\n\n# Check status\nst = MOI.get(lp, MOI.TerminationStatus())\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = MOI.get(lp, MOI.ObjectiveValue())\nx_ = MOI.get(lp, MOI.VariablePrimal(), x)\ny_ = MOI.get(lp, MOI.VariablePrimal(), y)\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"tutorials/lp_example/#Tulip","page":"Toy example","title":"Tulip","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"warning: Warning\nTulip's low-level API should not be considered stable nor complete. The recommended way to use Tulip is through JuMP/MOI as shown above.","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\nimport Tulip\n\n# Instantiate Tulip object\nlp = Tulip.Model{Float64}()\npb = lp.pbdata  # Internal problem data\n\n# Create variables\nx = Tulip.add_variable!(pb, Int[], Float64[], -2.0, 0.0, Inf, \"x\")\ny = Tulip.add_variable!(pb, Int[], Float64[], -1.0, 0.0, Inf, \"y\")\n\n# Add constraints\nrow1 = Tulip.add_constraint!(pb, [x, y], [1.0, -1.0], -2.0, Inf, \"row1\")\nrow2 = Tulip.add_constraint!(pb, [x, y], [2.0, -1.0], -Inf, 4.0, \"row2\")\nrow3 = Tulip.add_constraint!(pb, [x, y], [1.0,  2.0], -Inf, 7.0, \"row3\")\n\n# Set the objective\n# Nothing to do here as objective is already declared\n\n# Set some parameters\nTulip.set_parameter(lp, \"OutputLevel\", 0)  # disable output\nTulip.set_parameter(lp, \"Presolve_Level\", 0)     # disable presolve\n\n# Solve the problem\nTulip.optimize!(lp)\n\n# Check termination status\nst = Tulip.get_attribute(lp, Tulip.Status())\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = Tulip.get_attribute(lp, Tulip.ObjectiveValue())\nx_ = lp.solution.x[x]\ny_ = lp.solution.x[y]\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"manual/IPM/HSD/#Homogeneous-Self-Dual-algorithm","page":"Homogeneous Self-Dual","title":"Homogeneous Self-Dual algorithm","text":"","category":"section"},{"location":"manual/IPM/HSD/","page":"Homogeneous Self-Dual","title":"Homogeneous Self-Dual","text":"Tulip.HSD","category":"page"},{"location":"manual/IPM/HSD/#Tulip.HSD","page":"Homogeneous Self-Dual","title":"Tulip.HSD","text":"HSD\n\nSolver for the homogeneous self-dual algorithm.\n\n\n\n\n\n","category":"type"},{"location":"manual/IPM/HSD/#References","page":"Homogeneous Self-Dual","title":"References","text":"","category":"section"},{"location":"manual/IPM/HSD/","page":"Homogeneous Self-Dual","title":"Homogeneous Self-Dual","text":"Anjos, M.F.; Lodi, A.; Tanneau, M.   Design and implementation of a modular interior-point solver for linear optimization","category":"page"},{"location":"reference/API/","page":"Julia API","title":"Julia API","text":"Modules = [Tulip]\nPages = [\"tulip_julia_api.jl\"]","category":"page"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.BarrierIterations}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::BarrierIterations)\n\nQuery the BarrierIterations attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.ConstraintName,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::ConstraintName, i::Int)\n\nQuery the name of constraint i in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.ModelName}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ModelName)\n\nQuery the ModelName attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.Status}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::Status)\n\nQuery the Status attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.VariableLowerBound,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model{T}, ::VariableLowerBound, j::Int)\n\nQuery the lower bound of variable j in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.VariableName,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::VariableName, j::Int)\n\nQuery the name of variable j in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T},Tulip.DualObjectiveValue}} where T","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::DualObjectiveValue)\n\nQuery the DualObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T},Tulip.ObjectiveValue}} where T","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ObjectiveValue)\n\nQuery the ObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_parameter-Tuple{Tulip.Model,String}","page":"Julia API","title":"Tulip.get_parameter","text":"get_parameter(m::Model, pname::String)\n\nQuery the value of parameter pname in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.load_problem!-Union{Tuple{T}, Tuple{Tulip.Model{T},String}} where T","page":"Julia API","title":"Tulip.load_problem!","text":"load_problem!(m::Model{T}, fname::String)\n\nRead a model from file fname and load it into model m.\n\nOnly free MPS files are currently supported.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.ConstraintName,Int64,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::ConstraintName, i::Int, name::String)\n\nSet the name of constraint i in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.ModelName,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(model::Model, ::ModelName, name::String)\n\nSet the ModelName attribute in model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.VariableName,Int64,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::VariableName, j::Int, name::String)\n\nSet the name of variable j in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T},Tulip.ConstraintLowerBound,Int64,T}} where T","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{T}, ::ConstraintLowerBound, i::Int, lb::T)\n\nSet the lower bound of constraint i in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T},Tulip.ConstraintUpperBound,Int64,T}} where T","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{T}, ::ConstraintUpperBound, i::Int, ub::T)\n\nSet the upper bound of constraint i in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T},Tulip.VariableLowerBound,Int64,T}} where T","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{T}, ::VariableLowerBound, j::Int, lb::T)\n\nSet the lower bound of variable j in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{T}, Tuple{Tulip.Model{T},Tulip.VariableUpperBound,Int64,T}} where T","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{T}, ::VariableUpperBound, j::Int, ub::T)\n\nSet the upper bound of variable j in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_parameter-Tuple{Tulip.Model,String,Any}","page":"Julia API","title":"Tulip.set_parameter","text":"set_parameter(m::Model, pname::String, val)\n\nSet the value of parameter pname in model m to val\n\n\n\n\n\n","category":"method"},{"location":"manual/formulation/#Problem-formulation","page":"Problem formulation","title":"Problem formulation","text":"","category":"section"},{"location":"manual/formulation/#Model-input","page":"Problem formulation","title":"Model input","text":"","category":"section"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"Tulip takes as input LP problems of the form","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrrcll\n    (P)    \n    displaystyle min_x  c^Tx  +  c_0\n    st\n     l^b_i leq  a_i^T x  leq u^b_i  forall i = 1  m\n     l^x_j leq  x_j  leq u^x_j  forall j = 1  n\n    endarray","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"where l^bx u^b x in mathbbR cup  - infty + infty , i.e., some of the bounds may be infinite.","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"This original formulation is then converted to standard form.","category":"page"},{"location":"manual/formulation/#Standard-form","page":"Problem formulation","title":"Standard form","text":"","category":"section"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"Internally, Tulip solves LPs of the form","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrl\n    (P)    \n    displaystyle min_x\n     c^T x +  c_0\n    st\n     A x = b\n     l leq x leq u\n    endarray","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"where x c in mathbbR^n, A in mathbbR^m times n, b in mathbbR^m, and  l u in (mathbbR cup -infty +infty )^n, i.e., some bounds may be infinite.","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"The original problem is automatically reformulated into standard form before the optimization is performed. This transformation is transparent to the user.","category":"page"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/attributes/#Attribute-reference","page":"Attributes","title":"Attribute reference","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Attributes are queried using get_attribute and set using set_attribute.","category":"page"},{"location":"reference/attributes/#Model-attributes","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nModelName String Name of the model\nNumberOfConstraints Int Number of constraints in the model\nNumberOfVariables Int Number of variables in the model\nObjectiveValue T Objective value of the current primal solution\nDualObjectiveValue T Objective value of the current dual solution\nObjectiveConstant T Value of the objective constant\nObjectiveSense  Optimization sense\nStatus  Model status\nBarrierIterations Int Number of barrier iterations\nSolutionTime Float64 Solution time, in seconds","category":"page"},{"location":"reference/attributes/#Variable-attributes","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nVariableLowerBound T Variable lower bound\nVariableUpperBound T Variable upper bound\nVariableObjectiveCoeff T Variable objective coefficient\nVariableName String Variable name","category":"page"},{"location":"reference/attributes/#Constraint-attributes","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nConstraintLowerBound T Constraint lower bound\nConstraintUpperBound T Constraint upper bound\nConstraintName String Constraint name","category":"page"},{"location":"reference/attributes/#Reference","page":"Attributes","title":"Reference","text":"","category":"section"},{"location":"reference/attributes/#Model-attributes-2","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractModelAttribute","category":"page"},{"location":"reference/attributes/#Tulip.BarrierIterations","page":"Attributes","title":"Tulip.BarrierIterations","text":"BarrierIterations\n\nNumber of iterations of the barrier algorithm in the last call.\n\nThis number may be zero in the following cases:\n\nthe model has been solved yet\npresolve solved the model\nthe initial solution was optimal\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.BarrierIterations())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.DualObjectiveValue","page":"Attributes","title":"Tulip.DualObjectiveValue","text":"DualObjectiveValue\n\nObjective value of the current dual solution.\n\nType: T\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.DualObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ModelName","page":"Attributes","title":"Tulip.ModelName","text":"ModelName\n\nThe name of the model.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ModelName(), \"lp_example\")\nTulip.get_attribute(model, Tulip.ModelName())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfConstraints","page":"Attributes","title":"Tulip.NumberOfConstraints","text":"NumberOfConstraints\n\nNumber of constraints in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfConstraints())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfVariables","page":"Attributes","title":"Tulip.NumberOfVariables","text":"NumberOfVariables\n\nNumber of variables in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfVariables())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveConstant","page":"Attributes","title":"Tulip.ObjectiveConstant","text":"ObjectiveConstant\n\nConstant objective offset, defaults to zero.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ObjectiveConstant(), zero(T))\nTulip.get_attribute(model, Tulip.ObjectiveConstant())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveSense","page":"Attributes","title":"Tulip.ObjectiveSense","text":"ObjectiveSense\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveValue","page":"Attributes","title":"Tulip.ObjectiveValue","text":"ObjectiveValue\n\nObjective value of the current primal solution.\n\nType: T\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.ObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.SolutionTime","page":"Attributes","title":"Tulip.SolutionTime","text":"SolutionTime\n\nTotal solution time, in seconds.\n\nType: Float64\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.SolutionTime())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.Status","page":"Attributes","title":"Tulip.Status","text":"Status\n\nModel status\n\nType:\n\nModifiable: No\n\nExamples\n\nTulip.get(model, Tulip.Status())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Variable-attributes-2","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractVariableAttribute","category":"page"},{"location":"reference/attributes/#Tulip.VariableLowerBound","page":"Attributes","title":"Tulip.VariableLowerBound","text":"VariableLowerBound\n\nVariable lower bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableLowerBound(), 1, zero(T))\nTulip.get_attribute(model, Tulip.VariableLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableName","page":"Attributes","title":"Tulip.VariableName","text":"VariableName\n\nName of the variable.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableName(), 1, \"x1\")\nTulip.get_attribute(model, Tulip.VariableName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableObjectiveCoeff","page":"Attributes","title":"Tulip.VariableObjectiveCoeff","text":"VariableObjectiveCoeff\n\nObjective coefficient of the variable.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableObjectiveCoeff(), 1, one(T))\nTulip.get_attribute(model, Tulip.VariableObjectiveCoeff(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableUpperBound","page":"Attributes","title":"Tulip.VariableUpperBound","text":"VariableUpperBound\n\nVariable upper bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableUpperBound(), 1, one(T))\nTulip.get_attribute(model, Tulip.VariableUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Constraint-attributes-2","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractConstraintAttribute","category":"page"},{"location":"reference/attributes/#Tulip.ConstraintLowerBound","page":"Attributes","title":"Tulip.ConstraintLowerBound","text":"ConstraintLowerBound\n\nConstraint lower bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintLowerBound(), 1, zero(T))\nTulip.get_attribute(model, Tulip.ConstraintLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintName","page":"Attributes","title":"Tulip.ConstraintName","text":"ConstraintName\n\nName of the constraint.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintName(), 1, \"c1\")\nTulip.get_attribute(model, Tulip.ConstraintName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintUpperBound","page":"Attributes","title":"Tulip.ConstraintUpperBound","text":"ConstraintUpperBound\n\nConstraint upper bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintUpperBound(), 1, one(T))\nTulip.get_attribute(model, Tulip.ConstraintUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"CurrentModule = Tulip.KKT","category":"page"},{"location":"manual/linear_systems/#Solving-linear-systems","page":"Solving linear systems","title":"Solving linear systems","text":"","category":"section"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"The interior-point algorithm in Tulip requires the solution, at each iteration, of the following symmetric quasi-definite augmented system","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"beginbmatrix\n    -(Theta^-1 + R_p)  A^T\n    A  R_d\nendbmatrix\nbeginbmatrix\n    Delta x\n    Delta y\nendbmatrix\n=\nbeginbmatrix\n    xi_d\n    xi_p\nendbmatrix","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"where","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Delta x Delta y are primal and dual search directions,\nA is the problem's constraint matrix,\nTheta, R_p and R_d are positive diagonal matrices,\nxi_p xi_d are right-hand side vectors.","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"The augmented system above can be reduced to the positive-definite normal equations system","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"beginarrayrl\nleft(\n    A (Theta^-1 + R_p)^-1 A^T + R_d\nright)\nDelta y\n =\nxi_p + A (Θ^-1 + R_p)^-1 xi_d\nDelta x = (Θ^-1 + R_p)^-1 (A^T Delta y - xi_d)\nendarray","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"If available and when selected, this reduction is transparent to the interior-point algorithm.","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"To enable the use of fast external libraries and/or specialized routines, the resolution of linear systems is performed by an [AbstractKKTSolver] object.","category":"page"},{"location":"manual/linear_systems/#Supported-linear-solvers","page":"Solving linear systems","title":"Supported linear solvers","text":"","category":"section"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Here is a list of currently supported linear solvers:","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Linear solver type System Backend Method\nDenseSPD Normal equations Dense / LAPACK Cholesky\nCholmodSQD Augmented system CHOLMOD LDLᵀ\nCholmodSPD Normal equations CHOLMOD Cholesky\nLDLFactSQD Augmented system LDLFactorizations.jl LDLᵀ\nKrylovSPD Normal equations Krylov.jl Krylov\nKrylovSID Augmented system[1] Krylov.jl Krylov\nKrylovSQD Augmented system[1] Krylov.jl Krylov","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"[1]: KrylovSIDs view the augmented system as a symmetric indefinite system, while KrylovSQDs exploit its 2x2 structure and quasi-definite property. See the reference documentation for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Tulip","category":"page"},{"location":"#Tulip.jl","page":"Home","title":"Tulip.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tulip is an open-source interior-point solver for linear programming.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tulip is 100% Julia, so install it just like any Julia package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add Tulip","category":"page"},{"location":"","page":"Home","title":"Home","text":"No additional building step is required.","category":"page"},{"location":"#Citing-Tulip.jl","page":"Home","title":"Citing Tulip.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Tulip in your work, we kindly ask that you cite the following reference. The PDF is freely available here, and serves as a user manual for advanced users.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@TechReport{Tulip.jl,\n    title = {{Tulip}.jl: an open-source interior-point linear optimization\n    solver with abstract linear algebra},\n    url = {https://www.gerad.ca/fr/papers/G-2019-36},\n    Journal = {Les Cahiers du Gerad},\n    Author = {Anjos, Miguel F. and Lodi, Andrea and Tanneau, Mathieu},\n    year = {2019}\n}","category":"page"},{"location":"reference/options/","page":"Options","title":"Options","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/options/#Options-reference","page":"Options","title":"Options reference","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameters can be queried and set through the get_parameter and set_parameter functions.","category":"page"},{"location":"reference/options/","page":"Options","title":"Options","text":"In all that follows, epsilon refers to the numerical precision, which is given by eps(Tv) where Tv is the arithmetic of the current model. For instance, in double-precision arithmetic, i.e., Tv=Float64, we have epsilon simeq 10^-16.","category":"page"},{"location":"reference/options/","page":"Options","title":"Options","text":"Factory","category":"page"},{"location":"reference/options/#Tulip.Factory","page":"Options","title":"Tulip.Factory","text":"Factory{T}\n\nFactory-like struct for passing options to lower-level components.\n\n\n\n\n\n","category":"type"},{"location":"reference/options/#Presolve","page":"Options","title":"Presolve","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"These parameters control the execution of the presolve phase. They should be called as \"Presolve_<Param>\".","category":"page"},{"location":"reference/options/#Linear-Algebra","page":"Options","title":"Linear Algebra","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"These parameters control the linear algebra implementation","category":"page"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nMatrixFactory See Factory Factory(SparseMatrixCSC)","category":"page"},{"location":"reference/options/#KKT-solvers","page":"Options","title":"KKT solvers","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nFactory See Factory KKT.CholmodSQD for Float64, KKT.LDLFactSQD otherwise","category":"page"},{"location":"reference/options/#Interior-Point","page":"Options","title":"Interior-Point","text":"","category":"section"},{"location":"reference/options/#Tolerances","page":"Options","title":"Tolerances","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Numerical tolerances for the interior-point algorithm.","category":"page"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nTolerancePFeas Primal feasibility tolerance sqrtepsilon\nToleranceDFeas Dual feasibility tolerance sqrtepsilon\nToleranceRGap Relative optimality gap tolerance sqrtepsilon\nToleranceIFeas Infeasibility tolerance sqrtepsilon","category":"page"},{"location":"reference/options/#Algorithmic-parameters","page":"Options","title":"Algorithmic parameters","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nBarrierAlgorithm Interior-point algorithm 1\nCorrectionLimit Maximum number of additional centrality corrections 5\nStepDampFactor Step 0.9995\nGammaMin Minimum value of gamma for computing correctors 0.1\nCentralityOutlierThreshold Relative threshold for computing extra centrality corrections 0.1\nPRegMin Minimum value of primal regularization sqrtepsilon\nDRegMin Minimum value of dual regularization sqrtepsilon","category":"page"},{"location":"reference/options/#Stopping-criterion","page":"Options","title":"Stopping criterion","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nIterationsLimit Maximum number of barrier iterations 100\nTimeLimit Time limit, in seconds Inf","category":"page"},{"location":"reference/options/#Others","page":"Options","title":"Others","text":"","category":"section"},{"location":"reference/options/","page":"Options","title":"Options","text":"Parameter Description Default\nOutputLevel Controls the solver's output 0\nThreads Maximum number of threads 1\nPresolve Presolve (no presolve if set to ≤ 0) 1","category":"page"}]
}
